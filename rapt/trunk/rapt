#!/usr/bin/perl
#
# Tool for setting up, exporting apt repositories and
# executing apt commands for only these repositories.
#
#   This program is free software; you can redistribute it and/or modify
#   it under the terms of the GNU General Public License as published by
#   the Free Software Foundation; either version 2 of the License, or
#   (at your option) any later version.
#
#   This program is distributed in the hope that it will be useful,
#   but WITHOUT ANY WARRANTY; without even the implied warranty of
#   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
#   GNU General Public License for more details.
#
#   You should have received a copy of the GNU General Public License
#   along with this program; if not, write to the Free Software
#   Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
#
# $Id$
#
# Author:
# (C)opyright Erich Focht <efocht@hpce.nec.com>
#      All rights reserved
# Update:
# (C)opyright Oak Ridge National Laboratory
#       Geoffroy Vallee <valleegr@ornl.gov>
#       All rights reserved
#
# # # #
#
# Local debian repository example (suppose version is 3.1, codename "sarge"):
#   Location of .deb files:
#   /tftpboot/distro/debian-3.1-i386/
#
#   Location of Packages and Packages.gz files (metadata):
#   /tftpboot/distro/debian-3.1-i386/dists/sarge/binaries-i386/Packages{,.gz}
#
#  This repository should be passed on the command line as:
#    --repo /tftpboot/distro/debian-3.1-i386
#  It will lead to the following entry in the temporary sources.list config
#  file in /etc/apt:
#  deb file:/tftpboot/distro/debian-3.1-i386/ sarge .
#
# # # #
#
# A remote debian repository that would e.g. be listed in the
# /etc/apt/sources.list file as
# deb http://http.us.debian.org/debian sarge main restricted
# should be passed on the command line as:
#  --repo http://http.us.debian.org/debian+sarge+main+restricted
#
# # # #
#
# WARNING rapt does not support currently multiple architectures.
#
# # # #



use strict;
use Getopt::Long;
use IO::File;
use POSIX qw(tmpnam);
use File::Basename;
use File::Copy;
use Carp;
use Switch;
# add the line below when ready for it
#use OSCAR::PackMan;

my ($verbose, $export, $unexport, $prepare, $listexp, $name_only);
my $installroot;
my (@repos, @repoadd, @repodel, $repolist);
my @delfiles;

Getopt::Long::Configure("pass_through");
GetOptions( 
        "help"          => \&help,
        "repo=s"        => \@repos,
#        "repoadd=s"    => \@repoadd,
#        "repodel=s"    => \@repodel,
        "names-only"    => \$name_only,
        "repolist"      => \$repolist,
        "export"        => \$export,
        "prepare"       => \$prepare,
        "unexport"      => \$unexport,
        "listexp"       => \&list_exported,
        "installroot=s" => \$installroot,
        "verbose|v+"    => \$verbose,
        );

$verbose = "$ENV{RAPT_VERBOSE}" if ($ENV{RAPT_VERBOSE});

# query default OSCAR repositories if no repo given
if (!scalar(@repos)) {
    &get_default_repos();
}

help() if (!scalar(@repos));

my @validarch = qw(i386 x86_64 ia64 ppc64 noarch);

if (check_repos (@repos)) {
    die "ERROR: Invalid repo(s)\n";
}

my @arches = get_arch_repos(@repos);
if (scalar(@arches) == 0) {
    print "Warning: Impossible to detect repositories architecture ".
          "(normal in case of online repo(s)).\n";
}

print "Supported architecture(s): [".join (" ", @arches)."]\n" if $verbose;

our $err = 0;
chomp(my $hostname=`hostname -s`);

if ($export || $unexport || $prepare) {
    if ($prepare) {
        foreach my $archstr (@arches) {
            my $march = $archstr;
            $march = "i?86" if ($archstr eq "i386");
            $err += prep_repodata($archstr);
        }
    }

    $err += add_httpd_conf() if ($export);
    $err += del_httpd_conf() if ($unexport);
    exit $err;
}

if (scalar(@repoadd) || scalar(@repodel) || $repolist) {
    if (@repodel) {
        &oscar_repocmd("repodel", @repodel);
    }
    if (@repoadd) {
        &oscar_repocmd("repoadd", @repoadd);
    }
    if ($repolist) {
        &oscar_repocmd("repolist",);
    }
    exit 0;
}

# chop trailing slashes from repository names
foreach (@repos) {
    s:\/$::;
}

#
# For debian we need to carefully distinguish between local and remote
# repositories. Installing into the master root filesystem can be done
# from a local repo (file:), installation into an image has to be done
# through a remote repo, as it runs in chroot!
#
for my $repo (@repos) {
    # prepend "file:" to absolute path repos
    if (($repo !~ /^(file|ftp|http)/) && -d $repo && ($repo=~/^\//)) {
        $repo = "file:".$repo;
    }
}


# install exit handler which removes the temporary
# files and releases the lock
END {my $rc = $?; cleanup(); exit $rc};

$SIG{INT} = \&cleanup;



##############################
### go for an apt-get command
##############################

# if command is "install" into empty image: debootstrap first
if ($installroot) {
    if ((scalar(grep /^install$/, @ARGV) == 1) && &img_needs_bootstrap) {
        # Warning: distro codename is detected from local installation...
        &debootstrap($installroot,&detect_codename);

        # Debian/Sarge sucks for one point: if we want to be able to install
        # kernel packages, the /etc/kernel-img.conf file has to be created
        # manually
        my $cmd = "echo \"do_initrd = Yes\" > $installroot/etc/kernel-img.conf";
        print ("Executing: $cmd\n") if $verbose;
        if (system($cmd)) {
            print ("Impossible to create file $installroot/etc/kernel-img.conf");
        }
    }
    @repos = &repo_file2http;
}

# lock source.list file such that concurrent "rapt"s wait for the lock
&lock_aptlist;

&backup_aptlist;

# create temporary sources.list file with proper repository paths
&new_aptlist;

# update Packages cache. Note that we turn off all output (including stderr),
# we are only interested by the return code.
my $cmd = "apt-get update";
$cmd = $cmd . " 1>/dev/null 2>/dev/null" if (!$verbose);
if ($installroot) {
    $cmd = "chroot $installroot $cmd";
}
print "Executing: $cmd\n" if $verbose;
$err = system($cmd);
if ($err) {
    die("Error occured while running \"$cmd\" ($err)");
}


# mount /proc into image if needed
if ($installroot) {
    if (!&img_has_proc) {
	&img_mount_proc;
    }
}
# shut up debconf
&shutup_debconf($installroot);

# disable start-stop-daemon
if ($installroot) {
    &install_fake_start_stop_daemon($installroot);
}

# run apt-get command
my $cmd = "apt-get";
$cmd .= " ".join(" ",@ARGV);

if ($installroot) {
    $cmd = "chroot $installroot $cmd";
}

if ($ARGV[0] eq "search" && $name_only) {
    $cmd .= " -F \"%p\"";
}

# other preparing commands (cf. sin)

print "Executing: $cmd\n" if ($verbose);
$err = system($cmd);

# umount /proc into image if needed
if ($installroot) {
    &img_umount_proc;
}

# enable interactive debconf
&openup_debconf($installroot);

# enable start-stop-daemon
if ($installroot) {
    &uninstall_fake_start_stop_daemon($installroot);
}

&restore_aptlist;
&unlock_aptlist;

exit $err;


#############################################################################

sub help {
    print "Usage: $0 OPTIONS [APT_GET_OPTIONS]\n";
    print "\n";
    print "Call apt-get with _only_ the repositories passed on the command line .\n";
    print "OPTIONS can be:\n";
    print " --repo URL : repository which should be included in apt actions\n";
    print "              (multiple --repo options are possible).\n";
    print " --installroot DIR : install/remove packages to/from image DIR\n";
    print " --export   : create httpd configuration for local repositories\n";
    print " --unexport : delete httpd configuration for local repositories\n";
    print " --listexp  : list exported local repositories\n";
    print " --prepare  : generate repodata for local repositories\n";
    print " --help     : this help information\n";
#    print " --repoadd URL : add URL to the OSCAR repository list for the\n";
#    print "                 local node's distro/architecture.\n";
#    print " --repodel URL : delete URL from the OSCAR repository list for\n";
#    print "                 the local node's distro/architecture.\n";
    print " --repolist    : list the OSCAR repository URLs\n";
    print " --verbose  : verbose output\n";
    print "\n";
    print "APT_GET_OPTIONS are options to be passed to the apt-get command.\n";
    print "Setting the environment variable \$RAPT_VERBOSE to a number\n";
    print "between 1 and 10 will generate verbose output like multiple\n";
    print "-v options.\n\n";
    exit;
}

sub cleanup {
    for my $f (@delfiles) {
        if (-e $f) {
            !system("rm -f $f") or print "Couldn't remove file $f : $!\n";
        }
    }
    &restore_aptlist;
}

sub get_default_repos {
    # if OSCAR_HOME is defined, we're probably on a master
    my $dquery;
    if ($ENV{OSCAR_HOME}) {
        $dquery = "$ENV{OSCAR_HOME}/scripts/distro-query";
    } else {
        $dquery = "/usr/bin/distro-query";
    }

	if (-x $dquery) {
	    if ($installroot && (-x "$installroot/bin/bash")) {
	        $dquery = $dquery . " --image $installroot";
	    }
	    print "Executing: $dquery\n" if ($verbose);
	    local *CMD;
	    open CMD, "$dquery |" or die "Could not run $dquery: $!";
	    while (<CMD>) {
	        chomp;
	        if (/Distro package url : (\S.*)$/) {
	            push @repos, split(",",$1);
	        } elsif (/OSCAR package pool : (\S.*)$/) {
	            push @repos, split(",",$1);
	        }
	    }
	    close CMD;
	} else {
	    print "distro-query not found ($dquery)\n";
	    print "Unable to detect default repositories.\n";
    }
	my $master = gethostbyname("oscar_server");
	if ($master) {
	    my $node=`hostname`; chomp $node;
	    print "Executing: ssh oscar_server \\\$OSCAR_HOME/scripts/distro-query --node $node\n" if ($verbose);
	    local *CMD;
	    open CMD, "ssh oscar_server \\\$OSCAR_HOME/scripts/distro-query --node $node |";
	    while (<CMD>) {
		chomp;
		if (/Distro package url : (\S+)$/) {
            push @repos, split(",",$1);
		} elsif (/OSCAR package pool : (\S+)$/) {
            push @repos, split(",",$1);
		}
	    }
	    close CMD;
	} #else {
# 	    print "You are not on an OSCAR cluster. You must specify a repository!\n";
# 	    help();
# 	}
    if ($verbose) {
        print "Repositories detected:\n\t".join("\n\t",@repos)."\n";
    }
}

################################################################################
# We add an element in a array avoiding duplication. Note that we write these  #
# functions from scratch, i.e., we do not use OSCAR modules in order to avoid  #
# bootstrap issues.                                                            #
#                                                                              #
# Input: elt, element to add to the array,                                     #
#        array, array the element has to be added to.                          #
# Return: a separate array with the element added if the element was not       #
# therefore before.                                                            #
################################################################################
sub add_to_array ($@) {
    my ($elt, @array) = @_;

    print "Adding $elt to [".join(" ", @array)."] without duplication\n"
        if $verbose;

    my $found = 0;
    foreach my $e (@array) {
        if ($e eq $elt) {
            $found = 1;
            last;
        }
    }
    if ($found == 0) {
        push (@array, $elt);
    }
    print "New array: [".join(" ", @array)."]\n" if $verbose;
    return @array;
}

################################################################################
# Detect architectures from repositories' name.                                #
# Note that because the Debian repository structure is completely different    #
# from the yum repositories, we have do little tricks. This is because of two  #
# reasons:                                                                     #
#   - An historical reason: OSCAR has been initially designed for RPM-based    #
#     only systems and therefore some of the basic OSCAR tools are based on    #
#     RPM stuff and it is a pretty bad idea to want to change them (at least   #
#     currently the different structures are coherent even if it implies more  #
#     details to deal with on Debian based systems.                            #
#   - To make OSCAR coherent, we use OS_Detect for the detection of distros.   #
#     OS_Detect is pretty powerful, we want to preserve it. However, OS_Detect #
#     assumes repositories by their structures (common versus distro specific) #
#     are yum-like repositories.                                               #
# Based on this context, for common-deb repositories which are completely      #
# unatural on Debian, we scan for architecture specific pool in                #
# /tftpboot/oscar, get their architecture and generate the repo for common     #
# based on EACH of these architectures.                                        #
#                                                                              #
# @param: list of repositories.                                                #
# @return: list of architectures (via an array of strings).                    #
#                                                                              #
# TODO: detect format of online repos. This may be usefull if we want to mix   #
#       online and local repos: the local common-debs repo will also be ready  #
#       for online repos.                                                      #
################################################################################
sub get_arch_repos (@) {
    my (@repos) = @_;
    my @arch;
    my $varch = join("|",@validarch);
    for my $repo (@repos) {
        $repo = get_loal_repository_path ($repo);
        # We skip online repos, which is a bad idea when mixing online and
        # local repos.
        next if (!defined ($repo));
        my $r = basename($repo);
        chomp($r);
        print "Detecting architecture of $r...\n" if $verbose;
        $r =~ s:/$::;
        if (!index ($r,"common-",0)) {
                # if the repo is a repo for comon packages, it is a special
                # case since no real architecture is associated. In Debian
                # packages are supposed to all be in "pool" and only
                # repository metadata is supposed to be organized by
                # architecture.
                # Therefore in our case, for the common repo, we check
                # architectures within /tftpboot/oscar/distro and create an
                # assocaited repo for all of them
                my @sub_repos = `find /tftpboot/oscar -name \"debian-*\"`;
                my $r2;
                for $r2 (@sub_repos) {
                    chomp ($r2);
                    my @ret = get_arch_repos ($r2);
                    foreach my $subrep (@ret) {
                        @arch = add_to_array($subrep, @arch);
                    }
                }
        } elsif (($r =~ /(.*)\-(\d+)\-($varch)(|\.url)$/) ||
                ($r =~ /(.*)\-(\d+.\d+)\-($varch)(|\.url)$/)) {
            my $a = $3;
            if ($a eq "x86_64") {
                @arch = add_to_array ("amd64", @arch);
            } else {
                @arch = add_to_array ($a, @arch);
            }
        } else {
            print "WARNING: repository name doesn't match any valid architecture\n";
        }
    }
    print "Detected architecture(s): ". join (" ", @arch) . "\n" if $verbose;
    return @arch;
}


# simple check: does image need debootstrap to be installed?
sub img_needs_bootstrap {
    if (!$installroot || ($installroot eq "/") || (-d "$installroot/etc/apt")) {
        return 0;
    } else {
        return 1;
    }
}


# convert local (file:) repositories to remote http: URLs
sub repo_file2http {
    my @remote;
    for my $repo (@repos) {
	if ($repo =~ /^file:/) {
	    $repo =~ s,^file:,http://127.0.0.1/repo,;
	}
	push @remote, $repo;
    }
    return @remote;
}

# is /proc mounted in the image?
sub img_has_proc {
    local *IN;
    my $hasproc;
    open IN, "/proc/mounts" or croak "Cannot open /proc/mounts: $!";
    while (<IN>) {
	if (m:$installroot/proc:) {
	    $hasproc = 1;
	    last;
	}
    }
    close IN;
    return $hasproc;
}

# check if image already has /proc mounted, mount it otherwise
sub img_mount_proc {
    if (!&img_has_proc()) {
	!system("mount --bind /proc $installroot/proc")
	    or croak "Could not mount /proc into $installroot: $!";
    }
}

# unmount /proc from image
sub img_umount_proc {
    if (&img_has_proc()) {
	!system("umount $installroot/proc")
	    or croak "Could not umount /proc in $installroot: $!";
    }
}

#####
# routines taken from systeminstaller Deboot.pm
#####
sub shutup_debconf {
# Preconfigure the debconf database for maximum non-interactivity
# Input:	image path
# Returns:	1 on success, 0 on failure.
	my $imgpath = shift;
	my $config = "$imgpath/var/cache/debconf/config.dat";

	print "Configuring debconf to use the Noninteractive interface.\n"
	    if $verbose;
	open(NEW_CONFIG, ">>$config") or close OLD_CONFIG and return 1;
	print NEW_CONFIG << 'EOF';
Name: debconf/frontend
Template: debconf/frontend
Value: Noninteractive
Owners: debconf
Flags: seen
EOF
	close NEW_CONFIG;
	return 0;
}

sub openup_debconf {
# Undo what shutup_debconf did, removing the Noninteractive setting.
# Input:	image path
# Returns:	1 on success, 0 on failure.
    my $imgpath = shift;
    my $active = 0;

    my $config = "$imgpath/var/cache/debconf/config.dat";
    my $tmp = "$imgpath/var/cache/debconf/config.dat.RAPT.tmp";

    print "Configuring debconf to use the Dialog interface.\n" if $verbose;
    rename $config, $tmp or return 1;

    open(OLD_CONFIG, "<$tmp") or return 1;
    open(NEW_CONFIG, ">$config") or close OLD_CONFIG and return 1;
    while (<CONFIG>) {
	if (/^Name: debconf\/frontend$/) {
	    $active = 1;
	}
	if ($active == 1 and /^\s*$/) {
	    $active = 0;
	}
	if ($active == 1 and /^Value: Noninteractive$/) {
	    print NEW_CONFIG "Value: Dialog\n";
	    $active = 0;
	    next;
	}
	print NEW_CONFIG;
    }
    close OLD_CONFIG;
    close NEW_CONFIG;
    return 0;
}

sub install_fake_start_stop_daemon {
# puts a fake start-stop-daemon in place, to prevent daemons from
# starting on the build system.
# Input: image path
# Output: 0 on success, non-zero on failure.

    my $imgpath=shift;

    print "Installing fake start-stop-daemon.\n" if $verbose;
    rename "$imgpath/sbin/start-stop-daemon", 
	"$imgpath/sbin/start-stop-daemon.RAPT.tmp" or return 1;
    open(SSD, ">$imgpath/sbin/start-stop-daemon") or return 1;
    print SSD "#!/bin/sh\n";
    print SSD "echo\n";
    print SSD "echo Warning: Fake start-stop-daemon called, doing nothing\n";
    close SSD;
    chmod 0755, "$imgpath/sbin/start-stop-daemon" or return 1;
}


sub uninstall_fake_start_stop_daemon {
# puts a fake start-stop-daemon in place, to prevent daemons from
# starting on the build system.
# Input: image path
# Output: 0 on success, non-zero on failure.

    my $imgpath=shift;
	
    print "Uninstalling fake start-stop-daemon.\n" if $verbose;
    unlink "$imgpath/sbin/start-stop-daemon" or return 1;
    rename "$imgpath/sbin/start-stop-daemon.RAPT.tmp", 
	"$imgpath/sbin/start-stop-daemon" or return 1;
}	    

################################################################################
# We try to find the mirror we use for the Debian packages when using online   #
# repos. Unfortunately, we only have a list of repos and we do not know which  #
# one can be used by debootstrap. Therefore we check if one f them is from a   #
# file in /tftpboot/distro. If so, we assume this is the mirror we want to use #
# with debootstrap.                                                            #
# The code is kind of ugly but there is not a real alternative since in RAPT   #
# there is currently no way to know the distribution ID (which is a strong     #
# limitation). The code could be much more simple if instead of dealing with   #
# an anonymous list of repositories we could just have the distro ID and only  #
# then we automatically get the list of associated distros (we can already get #
# such a list).                                                                #
#                                                                              #
# Input: None.                                                                 #
# Return: the mirror URL, empty string if no mirror is found.                  #
################################################################################
sub get_debootstrap_mirror () {
    my $mirror = "";

    foreach my $r (@repos) {
        my $distro_repo = `grep -r $r /tftpboot/distro`;
        if ($distro_repo ne "") {
            my $url_file;
            ($url_file, $distro_repo) = split (".url:", $distro_repo);
            my @array = split (/\+/, $distro_repo);
            $mirror = $array[0];
        }
    }

    return $mirror;
}

sub debootstrap ($$$) {
# debootstrap is used to install the base system into a chroot
# Input:      target, suite, mirror
# Returns:    0 if failure, 1 if ok
    my $target = shift;
    my $suite = shift;

    my $mirror = get_debootstrap_mirror ();

    if (system("which debootstrap 2>/dev/null")) {
        print "ERROR: Could not find command debootstrap!\n";
        exit 1;
    }

    # create directory if not existing
    if (! -d "$target") {
        !system("mkdir -p $target")
          or croak("Could not make directory $target: $!");
    }

    my $cmd = "debootstrap --verbose $suite $target $mirror";
    print "Executing: $cmd\n" if $verbose;
    if (system($cmd)) {
        print "Failed to debootstrap, aborting.\n";
        return 0;
    }
    # Debian/Sarge sucks for one point: if we want to be able to install
    # kernel packages, the /etc/kernel-img.conf file has to be created
    # manually
    $cmd = "echo \"do_initrd = Yes\" > $target/etc/kernel-img.conf";
    print ("Executing: $cmd\n");
    if (system ($cmd)) {
        print ("Error: cannot create the file $target/etc/kernel-img.conf");
        return 0;
    }
    return 1;
}

#######
# end #
#######


# this function returns the apt list filename
sub aptlist_name {
    return $installroot."/etc/apt/sources.list";
}

# create lock file in safe way
# function only returns successfully!
sub lock_aptlist {
    my $file = &aptlist_name."_lock";

    # create lockfile with other name
    my $tfile = $file."_".$$;
    write_pid($tfile);
    push @delfiles, $tfile;

  WAIT4LOCK:
    while (-e $file) {
	my $lpid = &read_pid($file);
	if ($lpid) {
	    if (! -d "/proc/$lpid") {
		print "Stale lock found for non-existing process $lpid.".
		    " Removing it!\n" if $verbose;
		unlink($file);
		last;
	    } else {
		print "Waiting for lock $file to be released...\n" if $verbose;
		sleep(3);
	    }
	} else {
	    print "Lock $file disappeared or empty !?!\n" if $verbose;
	    last;
	}
    }
    # Now try to acquire the lock
    $err = system("mv --reply=no $tfile $file 2>/dev/null");
    if ($err) {
	print "Couldn't acquire lock $file\n" if $verbose;
	goto WAIT4LOCK;
    }
    return;
}

sub unlock_aptlist {
    my $file = &aptlist_name . "_lock";
    my $pid = &read_pid($file);
    if ($pid != "$$") {
	print "WARNING! Unexpected pid $pid is holding the lock $file\n";
    } else {
	!system("rm -f $file") or carp("Could not remove lock $file: $!");
    }
}

sub backup_aptlist {
    my $file = &aptlist_name;
    my $backup = $file . "_bak$$";
    if (-f $file) {
	!system("mv $file $backup")
	    or carp("Could not back up $file to $backup: $!");
    }
}

sub restore_aptlist {
    my $file = &aptlist_name;
    my $backup = $file . "_bak$$";
    if (-e $backup) {
    	!system("mv $backup $file")
	        or carp("Could not restore $file from $backup: $!");
    # GV: WARNING, not executing "apt-get update", it is not possible to 
    # directly reuse apt-get! Users MUST execute manually "apt-get update"!!
#        !system("apt-get update")
#            or carp("Could not execute apt-get update");
    }
}

# create new sources.list file for apt resembling the current repositories
sub new_aptlist {
    my $file = &aptlist_name;
    my $backup = $file . "_bak$$";
    # We manually add the OSCAR repository entry.
    copy ($backup, $file);
    local *OUT;
    open OUT, "> $file" or croak("Could not open $file: $!");
    for my $repo (@repos) {
        my @data = split(/\+/,$repo);
    	# if there's only one word, add codename info
    	if (scalar(@data) == 1) {
	        my $codename = &detect_codename();
	        push @data, ($codename, ".");
    	} elsif (scalar(@data) == 2) {
	        push @data, ".";
	    }
	    print OUT "deb ".join(" ",@data)."\n";
    }
#    print OUT "deb http://oscar.gforge.inria.fr/debian/ stable main oscar";
    close OUT;
}

sub read_pid {
    my ($file) = @_;
    local *IN;
    open IN, "$file" 
	or do {
	    return 0 if (! -e $file);
	    croak "Could not open $file";
	};
    my $pid = <IN>;
    close IN;
    return $pid;
}

sub write_pid {
    my ($file) = @_;
    local *OUT;
    open OUT, "> $file" or croak "Could not create $file";
    print OUT "$$";
    close OUT;
}


###############################################################
# stuff below this line should be deleted once packman is used!

sub oscar_repocmd {
    my ($cmd, @r) = @_;
    if (!&on_oscar_master()) {
        print STDERR "ERROR: You can only do this on an OSCAR master node!\n";
        exit 1;
    }
    if ($cmd !~ m/^(repolist|repoadd|repodel)$/) {
        print STDERR "ERROR: Wrong command $cmd!\n";
        exit 1;
    }
    if ($installroot) {
        print STDERR "ERROR: You can't do this with --installroot!\n";
        exit 1;
    }
    eval "use lib \"$ENV{OSCAR_HOME}/lib\"";
    eval "use OSCAR::PackagePath";
    my $oscar_url;
    my $distro_url;
    my $pkg;
    eval "(\$oscar_url, \$pkg) = OSCAR::PackagePath::oscar_urlfile()";
    eval "\$distr_url = OSCAR::PackagePath::distro_urlfile()";
    if ($cmd eq "repoadd") {
        eval "OSCAR::PackagePath::repos_add_urlfile(\$oscar_url, \@r)";
    } elsif ($cmd eq "repodel") {
        eval "OSCAR::PackagePath::repos_del_urlfile(\$oscar_url, \@r)";
    }
    # repolist in any case
    my @repos;
    eval "\@repos = OSCAR::PackagePath::repos_list_urlfile(\$oscar_url)";
    print "Repositories in $oscar_url:\n    ".join("\n    ", @repos)."\n";
}


sub find_httpdir {
    my $httpdir;
    for my $d ("httpd", "apache", "apache2") {
	if (-d "/etc/$d/conf.d") {
	    $httpdir = "/etc/$d/conf.d";
	    last;
	} elsif (-d "/etc/$d/$d.conf") {
	    $httpdir = "/etc/$d/$d.conf";
	    last;
	}
    }
    if ($verbose) {
	print "Found httpdir = $httpdir\n";
    }
    return $httpdir;
}

# Exports repositories through httpd (http://$hostname/$pname)
sub add_httpd_conf {
    my $httpdir = find_httpdir();
    my $changed = 0;
    my $err = 0;
    if ($httpdir) {
	for my $repo (@repos) {
	    if ($repo =~ /^(file:\/|\/)/) {
		$repo =~ s|^file:||;
		if (!-d $repo) {
		    print "Could not find directory $repo. Skipping.\n";
		    $err++;
		    next;
		}
		my $pname = "repo$repo";
		my $rname = $pname;
		$rname =~ s:/:_:g;
		my $cname = "$httpdir/$rname.conf";
		if (-f $cname) {
		    print "Config file $cname already existing. Skipping.\n";
		    next;
		}
		print "Exporting $repo through httpd, http://$hostname/$pname\n";
		open COUT, ">$cname" or die "Could not open $cname : $!";
		print COUT "Alias /$pname $repo\n";
		print COUT "<Directory $repo/>\n";
		print COUT "  Options Indexes\n";
		print COUT "  order allow,deny\n";
		print COUT "  allow from all\n";
		print COUT "</Directory>\n";
		close COUT;
		++$changed;
	    } else {
		print "Repository URL is not a local absolute path!\n";
		print "Skipping $repo\n";
		$err++;
		next;
	    }
	}
    } else {
	print "Could not find directory $httpdir!\n";
	print "Cannot setup httpd configuration for repositories.\n";
	$err++;
    }
    restart_httpd() if ($changed);
    return $err;
}

sub del_httpd_conf {
    my $httpdir = find_httpdir();
    my $changed = 0;
    my $err = 0;
    if ($httpdir) {
	for my $repo (@repos) {
	    if ($repo =~ /^(file:\/|\/)/) {
		$repo =~ s|^file:||;
		my $pname = "repo$repo";
		my $rname = $pname;
		$rname =~ s:/:_:g;
		my $cname = "$httpdir/$rname.conf";
		if (-f $cname) {
		    print "Deleting config file $cname\n";
		    if (unlink($cname)) {
			print "WARNING: Could not delete $cname : $!\n";
			$err++;
		    } else {
			++$changed;
		    }
		}
	    } else {
		print "Repository URL is not a local absolute path!\n";
		print "Skipping $repo\n";
		$err++;
		next;
	    }
	}
    } else {
	print "Could not find directory $httpdir!\n";
	print "Cannot delete httpd configuration for repositories.\n";
	$err++;
    }
    restart_httpd() if ($changed);
    return $err;
}

sub list_exported {
    my $httpdir = find_httpdir();
    if ($httpdir) {
	for my $repoconf (glob("$httpdir/repo_*.conf")) {
	    my $rname = basename($repoconf,".conf");
	    my ($dummy, $alias,$rdir) = split(" ",`grep "^Alias" $repoconf`);
	    chomp $rdir;
	    print "URL $alias : Repository --repo $rdir\n";
	}
    }
    exit;
}

sub restart_httpd {
    for my $httpd ("httpd", "httpd2", "apache", "apache2") {
	if (-x "/etc/init.d/$httpd") {
	    print "Restarting $httpd\n";
	    system("/etc/init.d/$httpd restart");
	    last;
	}
    }
}

sub prep_repodata (@) {
    my @list_arch = @_;

    #
    # this routine should be replaced by the gencache call to a
    # packman instance when that will be available
    #

    if (system("which dpkg-scanpackages 2>/dev/null")) {
        print "ERROR: Could not find command dpkg-scanpackages!\n";
        exit 1;
    }

    foreach my $a (@list_arch) {
        # detect distribution codename
        # currently from the master server, should actually come from the pool
        my $codename = &detect_codename();
        my $subdir = "dists/$codename/binary-$a";
        my $err = 0;
        for my $repo (@repos) {
            next if ($repo =~ /^(http|ftp):/);
            next if ($repo =~ /(.url)$/);
            $repo =~ s/^file://;
            $repo =~ s/\/$//;
            die "ERROR: the repository directory does not exists" 
                if (! -d $repo);
            next if ($repo !~ m:^/:);

            # create directory for package metadata
            if (! -d "$repo/$subdir") {
                !system("mkdir -p $repo/$subdir")
                    or croak "Could not create directory $repo/$subdir";
            }

            # now generate the Package.gz file
            my $path = "$repo/$subdir/Packages*";
            if ( -f "$path" ) {
                require File::Path;
                print "Deleting $path...\n" if $verbose;
                File::Path::rmtree ("$path", 0, 0);
            }
            my $cmd = "cd $repo; dpkg-scanpackages ./ /dev/null";
            $cmd .= "| tee $subdir/Packages | gzip -c9 >$subdir/Packages.gz";
            print "Executing command: $cmd\n";
            $err += abs(system($cmd));
        }
    }
    return $err;
}

#
# Detect codename of the targetted debian distro (sarge, breezy, ...)
# Try to do the right thing:
# - if we're installing into an image and it is already bootstrapped:
#   read the /etc/debian-release or /etc/lsb-release files in the image
# - if we're installing into a non-debootstrapped image:
#   detect codename from the first repository name (first word after the URL)
# - if we're installing locally, detect codename by reading the local files
#   /etc/debian-release or /etc/lsb-release
#
sub detect_codename {
    my (%args) =@_;
    my $codename;

    # the environment variable RAPT_DISTRO_CODENAME overrides detections
    if ($ENV{RAPT_DISTRO_CODENAME}) {
	return $ENV{RAPT_DISTRO_CODENAME};
    }

    # what are we targetting?
    if (!$installroot) {
        # local node
        $codename = &detect_codename_dir();
    } else {
        # image
        $codename = &detect_codename_dir($installroot);
        if (!$codename) {
            $codename = &detect_codename_repo(@repos);
        }
    }
    if (!$codename) {
        croak("Could not detect distribution codename!");
    }
    if ($codename !~ /^(etch|breezy|ubuntu)$/) {
        croak("Unsupported distribution codename: $codename\n");
    }
    return $codename;
}

#
# This needs improvement. For a local repo it should be able to detect the
# codename by unpacking the debian-release or lsb-release file.
# 
sub detect_codename_repo {
    my (@repos) = @_;
    # the codename of a debian-alike repo is the word after the URL
    my $repo = $repos[0];
    my ($url,$codename,$dummy) = split(/\+/,$repo);

    # for local repositories try some more tricks
    if (!$codename && ($url =~ /^file:(\S+)$/)) {
	my $path = $1;
	my @cnames = glob("$path/dists/*");
	if (scalar(@cnames) == 1) {
	    $codename = basename($cnames[0]);
	} elsif (scalar(@cnames) > 1) {
	    print "Pool seems to contain multiple codenames!\n ".
		join(", ",@cnames)."\n";
	    print "Cannot identify codename!\n";
	} else {
	    # no codename subdirectory or glob expansion failed
	    #
	    # ... code missing here ...
	    # - find .deb packages containing lsb-release and debian-release
	    # - unpack them and detect the codename
	    print "... no code for virgin repo codename detection, yet ...\n";
	}
    }
    return $codename;
}

sub detect_codename_dir {
    my ($dir) = @_;
    my $codename;

    if (-f "$dir/etc/debian_version") {
        # There is a trick with Ubuntu systems: they have a non-valid 
        # /etc/debian_version and the ubuntu release data is actually in
        # /etc/lsb-release. So if we get data from this file and if it specifies
        # the system is an Ubuntu system we quit.
        require OSCAR::LSBreleaseParser;
        my $distro_id = OSCAR::LSBreleaseParser::parse_lsbrelease("/");
        if (defined ($distro_id) && $distro_id ne "") {
            require OSCAR::PackagePath;
            my ($d, $v, $a) = 
                OSCAR::PackagePath::decompose_distro_id ($distro_id);
            return $d if ($d eq "ubuntu");
        }

        # the codename for debian distribution is supposed to be the first
        # line of the /etc/debian_version file.
        # Moreover, we just support sarge (aka. Debian 3.1).
        open (IN, "$dir/etc/debian_version")
            or die "Can't open file: $!\n";
        $codename = <IN>;
        close IN;
        # Since the codename may have multiple forms (3.1 vs sarge for 
        # instance, we translate to a generic codename (e.g. 3.1->sarge)
        # WARNING a \n is added after the codename when we read the file!
        chomp($codename);
        switch ($codename) {
            case "3.0" { 
                $codename = "sarge"; 
            }
            case "3.1" {
                $codename = "sarge";
            }
            case "4.0" {
                $codename = "etch";
            }
        }
    } elsif (-f "$dir/etc/lsb-release") {
	# there is a chance for this being a ubuntu distro
	# it is not supported, yet, but we'll recognize it
	# in order to facilitate development for ubuntu
	open IN, "$dir/etc/lsb-release"
	    or croak "Cannot open $dir/etc/lsb-release: $!";
	while (<IN>) {
	    if (/^DISTRIB_CODENAME=(.*)$/) {
		$codename = $1;
	    }
	}
	close IN;
    }
    return $codename;
}

################################################################################
# This function does basic checking about the repos we are supposed to deal    #
# with.                                                                        #
#                                                                              #
# Input: repos, an array with a list of repos path.                            #
# Return: 0 if repos are valid, -1 else.                                       #
################################################################################
sub check_repos (@) {
    my @repos = @_;

    print "Checking repositories validity...\n" if $verbose;
    # Currently we only check if the directory of the repo exists (it should!).
    foreach my $repo (@repos) {
        print "Checking repo $repo.\n" if $verbose;
        $repo = get_loal_repository_path ($repo);
        if ( defined ($repo) ) {
            print "Repository $repo is valid\n" if $verbose;
        } else {
            print "Online repository, we assume the repo is correct\n" 
                if $verbose;
        }
    }
    print "Repositories are valid.\n" if $verbose;
    return 0;
}

################################################################################
# This function just format the repo path; three cases are possible:           #
# - the repo path is "file:/tftpboot/...", in that case, we remove "file:",    #
# - the repo is online and therefore starts by http or ftp, in that case we    #
#   return undef,                                                              #
# - the repo is just a normal path (e.g., /tftpboot/oscar/debian-4-x86_64), in #
#   that case, we check if the directory exists and if so, return the path.    #
#                                                                              #
# Input: repo, the repository "path" we need to "clean up".                    #
# Return: the local directory path for the repo (directly usable by Perl),     #
#         undef if it is an online repository and die if the local repo does   #
#         not exist.                                                           #
################################################################################
sub get_loal_repository_path ($) {
    my $repo = shift;

    return undef if ($repo =~ /^(http|ftp)/);

    $repo =~ s/^file://;

    if ($repo =~ /(.url)$/) {
        print "URL file, looks valid\n" if $verbose;
    } elsif ( ! -d $repo) {
        die "ERROR: Invalid repo path ($repo)\n";
    }

    return $repo;
}
