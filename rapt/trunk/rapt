#!/usr/bin/perl
#
# Tool for setting up, exporting apt repositories and
# executing apt commands for only these repositories.
#
#   This program is free software; you can redistribute it and/or modify
#   it under the terms of the GNU General Public License as published by
#   the Free Software Foundation; either version 2 of the License, or
#   (at your option) any later version.
#
#   This program is distributed in the hope that it will be useful,
#   but WITHOUT ANY WARRANTY; without even the implied warranty of
#   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
#   GNU General Public License for more details.
#
#   You should have received a copy of the GNU General Public License
#   along with this program; if not, write to the Free Software
#   Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
#
# $Id$
#
# Author:
# (C)opyright Erich Focht <efocht@hpce.nec.com>
#      All rights reserved
# Update:
# (C)opyright Oak Ridge National Laboratory
#       Geoffroy Vallee <valleegr@ornl.gov>
#       All rights reserved
#
# # # #
#
# Local debian repository example (suppose version is 3.1, codename "sarge"):
#   Location of .deb files:
#   /tftpboot/distro/debian-3.1-i386/
#
#   Location of Packages and Packages.gz files (metadata):
#   /tftpboot/distro/debian-3.1-i386/dists/sarge/binaries-i386/Packages{,.gz}
#
#  This repository should be passed on the command line as:
#    --repo /tftpboot/distro/debian-3.1-i386
#  It will lead to the following entry in the temporary sources.list config
#  file in /etc/apt:
#  deb file:/tftpboot/distro/debian-3.1-i386/ sarge .
#
# # # #
#
# A remote debian repository that would e.g. be listed in the
# /etc/apt/sources.list file as
# deb http://http.us.debian.org/debian sarge main restricted
# should be passed on the command line as:
#  --repo http://http.us.debian.org/debian+sarge+main+restricted
#
# # # #
#
# WARNING rapt does not support currently multiple architectures.
#
# # # #



use strict;
use Getopt::Long;
use IO::File;
use POSIX qw(tmpnam);
use File::Basename;
use Carp;
use Switch;
# add the line below when ready for it
#use OSCAR::PackMan;

my ($verbose, $export, $unexport, $prepare, $listexp);
my $installroot;
my @repos;
my @delfiles;


Getopt::Long::Configure("pass_through");
GetOptions( 
        "help"      => \&help,
        "repo=s"    => \@repos,
        "export"    => \$export,
        "prepare"   => \$prepare,
        "unexport"  => \$unexport,
        "listexp"   => \&list_exported,
        "installroot=s" => \$installroot,
        "verbose|v+"    => \$verbose,
        );

$verbose = "$ENV{RAPT_VERBOSE}" if ($ENV{RAPT_VERBOSE});

# query default OSCAR repositories if no repo given
if (!scalar(@repos)) {
    &get_default_repos();
}	    

help() if (!scalar(@repos));

my @validarch = qw(i386 x86_64 ia64 ppc64 noarch);

my $archstr = &get_arch_repos(@repos);
my $march = $archstr;
$march = "i?86" if ($archstr eq "i386");

chomp(my $hostname=`hostname -s`);

if ($export || $unexport || $prepare) {
    my $err;
    $err = add_httpd_conf() if ($export);
    $err = del_httpd_conf() if ($unexport);
    $err = prep_repodata() if ($prepare);
    exit $err;
}


# chop trailing slashes from repository names
foreach (@repos) {
    s:\/$::;
}

#
# For debian we need to carefully distinguish between local and remote
# repositories. Installing into the master root filesystem can be done
# from a local repo (file:), installation into an image has to be done
# through a remote repo, as it runs in chroot!
#
for my $repo (@repos) {
    # prepend "file:" to absolute path repos
    if (($repo !~ /^(file|ftp|http)/) && -d $repo && ($repo=~/^\//)) {
        $repo = "file:".$repo;
    }
}


# install exit handler which removes the temporary
# files and releases the lock
END {cleanup()};

$SIG{INT} = \&cleanup;



#############################
### go for an apt-get command
#############################

# if command is "install" into empty image: debootstrap first
if ($installroot) {
    if ((scalar(grep /^install$/, @ARGV) == 1) && &img_needs_bootstrap) {

        # EF: don't know yet how to use a local repository for debootstrap
        # therefore using default remote repository
        # Warning: distro codename is detected from local installation...
        &debootstrap($installroot,&detect_codename);

        # Debian/Sarge sucks for one point: if we want to be able to install
        # kernel packages, the /etc/kernel-img.conf file has to be created
        # manually
        my $cmd = "echo \"do_initrd = Yes\" > $installroot/etc/kernel-img.conf";
        print ("Executing: $cmd\n");
        if (system($cmd)) {
            print ("Impossible to create file $installroot/etc/kernel-img.conf");
        }

    }
    @repos = &repo_file2http;
}

# lock source.list file such that concurrent "rapt"s wait for the lock
&lock_aptlist;

&backup_aptlist;

# create temporary sources.list file with proper repository paths
&new_aptlist;

# update Packages cache
my $cmd = "apt-get update";
if ($installroot) {
    $cmd = "chroot $installroot $cmd";
}
print "Executing: $cmd\n" if $verbose;
!system($cmd) or croak("Error occured while running \"$cmd\"");


# mount /proc into image if needed
if ($installroot) {
    if (!&img_has_proc) {
	&img_mount_proc;
    }
}
# shut up debconf
&shutup_debconf($installroot);

# disable start-stop-daemon
if ($installroot) {
    &install_fake_start_stop_daemon($installroot);
}

# run apt-get command
my $cmd = "apt-get";
$cmd .= " ".join(" ",@ARGV);

if ($installroot) {
    $cmd = "chroot $installroot $cmd";
}

# other preparing commands (cf. sin)

print "Executing: $cmd\n" if ($verbose);
my $err = system($cmd);

# umount /proc into image if needed
if ($installroot) {
    &img_umount_proc;
}

# enable interactive debconf
&openup_debconf($installroot);

# enable start-stop-daemon
if ($installroot) {
    &uninstall_fake_start_stop_daemon($installroot);
}


&restore_aptlist;
&unlock_aptlist;

exit $err;


#############################################################################

sub help {
    print "Usage: $0 OPTIONS [APT-GET_OPTIONS]\n";
    print "\n";
    print "Call apt-get with _only_ the repositories passed on the command line .\n";
    print "OPTIONS can be:\n";
    print " --repo URL : repository which should be included in apt actions\n";
    print "              (multiple --repo options are possible).\n";
    print " --installroot DIR : install/remove packages to/from image DIR\n";
    print " --export   : create httpd configuration for local repositories\n";
    print " --unexport : delete httpd configuration for local repositories\n";
    print " --listexp  : list exported local repositories\n";
    print " --prepare  : generate repodata for local repositories\n";
    print " --help     : this help information\n";
    print " --verbose  : verbose output\n";
    print "\n";
    print "APT-GET_OPTIONS are options to be passed to the yum command.\n";
    print "Setting the environment variable \$RAPT_VERBOSE to a number\n";
    print "between 1 and 10 will generate verbose output like multiple\n";
    print "-v options.\n\n";
    exit;
}

sub cleanup {
    for my $f (@delfiles) {
	if (-e $f) {
	    !system("rm -f $f") or print "Couldn't remove file $f : $!\n";
	}
    }
    &restore_aptlist;
}

sub get_default_repos {
    # if OSCAR_HOME is defined, we're probably on a master
    if ($ENV{OSCAR_HOME}) {
	my $dquery = "$ENV{OSCAR_HOME}/scripts/distro-query";
	if (-x $dquery) {
	    if ($installroot && (-x "$installroot/bin/bash")) {
		$dquery = $dquery . " --image $installroot";
	    }
	    print "Executing: $dquery\n" if ($verbose);
	    local *CMD;
	    open CMD, "$dquery |" or die "Could not run $dquery: $!";
	    while (<CMD>) {
		chomp;
		if (/Distro package url : (\S.*)$/) {
		    push @repos, split(",",$1);
		} elsif (/OSCAR package pool : (\S.*)$/) {
		    push @repos, $1;
		}
	    }
	    close CMD;
	} else {
	    print "Command $ENV{OSCAR_HOME}/scripts/distro-query not found\n";
	    print "Unable to detect default repositories.\n";
	}
    } else {
	my $master = gethostbyname("oscar_server");
	if ($master) {
	    my $node=`hostname`; chomp $node;
	    print "Executing: ssh oscar_server \\\$OSCAR_HOME/scripts/distro-query --node $node\n" if ($verbose);
	    local *CMD;
	    open CMD, "ssh oscar_server \\\$OSCAR_HOME/scripts/distro-query --node $node |";
	    while (<CMD>) {
		chomp;
		if (/Distro package url : (\S+)$/) {
		    push @repos, $1;
		} elsif (/OSCAR package pool : (\S+)$/) {
		    push @repos, $1;
		}
	    }
	    close CMD;
	} else {
	    print "You are not on an OSCAR cluster. You must specify a repository!\n";
	    help();
	}
    }
    if ($verbose) {
	print "Repositories detected:\n\t".join("\n\t",@repos)."\n";
    }
}

# guess architectures from repositories' name
# @param: list of repositories
# @return: list of architectures
# GV: this function is weird because we get a list of repos (which may be for
# different architecture) but we return only one architecture!!.
# WARNING, currently we do not return a list of architectures
sub get_arch_repos {
    my (@repos) = @_;
    my $arch;
    my $varch = join("|",@validarch);
    for my $r (@repos) {
	$r =~ s:/$::;
        if (!index ($r,"/tftpboot/oscar/common",0)) {
                # if the repo is a repo for comon packages, it is a special 
                # case since no real architecture is associated. In Debian 
                # packages are supposed to all be in "pool" and only 
                # repository metadata is supposed to be organized by 
                # architecture.
                # Therefore in our case, for the common repo, we check
                # architectures within /tftpboot/oscar/distro and create an
                # assocaited repo for all of them
                my @sub_repos = `find /tftpboot/oscar -name \"debian*\"`;
                my $r2;
                for $r2 (@sub_repos) {
                        $arch = get_arch_repos ($r2);
                        chomp ($arch);
                }
	} elsif ($r =~ m/-([^-]+)$/) {
	    my $a = $1;
	    if ($a =~ /^($varch)$/) {
		if (!$arch) {
		    $arch = $a;
		} else {
		    if ($arch ne $a) {
			print "WARNING: multiple architecture repos specified.\n";
		    }
		}
	    } else {
		print "WARNING: repository name doesn't match any valid architecture\n";
	    }
	} 
    }
    if ($arch && $verbose) {
	print "Architecture: $arch\n";
    }
    return $arch;
}


# simple check: does image need debootstrap to be installed?
sub img_needs_bootstrap {
    if (!$installroot || ($installroot eq "/") || (-d "$installroot/etc/apt")) {
	return 0;
    } else {
	return 1;
    }
}


# convert local (file:) repositories to remote http: URLs
sub repo_file2http {
    my @remote;
    for my $repo (@repos) {
	if ($repo =~ /^file:/) {
	    $repo =~ s,^file:,http://127.0.0.1/repo,;
	}
	push @remote, $repo;
    }
    return @remote;
}

# is /proc mounted in the image?
sub img_has_proc {
    local *IN;
    my $hasproc;
    open IN, "/proc/mounts" or croak "Cannot open /proc/mounts: $!";
    while (<IN>) {
	if (m:$installroot/proc:) {
	    $hasproc = 1;
	    last;
	}
    }
    close IN;
    return $hasproc;
}

# check if image already has /proc mounted, mount it otherwise
sub img_mount_proc {
    if (!&img_has_proc()) {
	!system("mount --bind /proc $installroot/proc")
	    or croak "Could not mount /proc into $installroot: $!";
    }
}

# unmount /proc from image
sub img_umount_proc {
    if (&img_has_proc()) {
	!system("umount $installroot/proc")
	    or croak "Could not umount /proc in $installroot: $!";
    }
}

#####
# routines taken from systeminstaller Deboot.pm
#####
sub shutup_debconf {
# Preconfigure the debconf database for maximum non-interactivity
# Input:	image path
# Returns:	1 on success, 0 on failure.
	my $imgpath = shift;
	my $config = "$imgpath/var/cache/debconf/config.dat";

	print "Configuring debconf to use the Noninteractive interface."
	    if $verbose;
	open(NEW_CONFIG, ">>$config") or close OLD_CONFIG and return 1;
	print NEW_CONFIG << 'EOF';
Name: debconf/frontend
Template: debconf/frontend
Value: Noninteractive
Owners: debconf
Flags: seen
EOF
	close NEW_CONFIG;
	return 0;
}

sub openup_debconf {
# Undo what shutup_debconf did, removing the Noninteractive setting.
# Input:	image path
# Returns:	1 on success, 0 on failure.
    my $imgpath = shift;
    my $active = 0;

    my $config = "$imgpath/var/cache/debconf/config.dat";
    my $tmp = "$imgpath/var/cache/debconf/config.dat.RAPT.tmp";

    print "Configuring debconf to use the Dialog interface.\n" if $verbose;
    rename $config, $tmp or return 1;
	    
    open(OLD_CONFIG, "<$tmp") or return 1;
    open(NEW_CONFIG, ">$config") or close OLD_CONFIG and return 1;
    while (<CONFIG>) {
	if (/^Name: debconf\/frontend$/) {
	    $active = 1;
	}
	if ($active == 1 and /^\s*$/) {
	    $active = 0;
	}
	if ($active == 1 and /^Value: Noninteractive$/) {
	    print NEW_CONFIG "Value: Dialog\n";
	    $active = 0;
	    next;
	}
	print NEW_CONFIG;
    }
    close OLD_CONFIG;
    close NEW_CONFIG;
    return 0;
}

sub install_fake_start_stop_daemon {
# puts a fake start-stop-daemon in place, to prevent daemons from
# starting on the build system.
# Input: image path
# Output: 0 on success, non-zero on failure.

    my $imgpath=shift;

    print "Installing fake start-stop-daemon.\n" if $verbose;
    rename "$imgpath/sbin/start-stop-daemon", 
	"$imgpath/sbin/start-stop-daemon.RAPT.tmp" or return 1;
    open(SSD, ">$imgpath/sbin/start-stop-daemon") or return 1;
    print SSD "#!/bin/sh\n";
    print SSD "echo\n";
    print SSD "echo Warning: Fake start-stop-daemon called, doing nothing\n";
    close SSD;
    chmod 0755, "$imgpath/sbin/start-stop-daemon" or return 1;
}


sub uninstall_fake_start_stop_daemon {
# puts a fake start-stop-daemon in place, to prevent daemons from
# starting on the build system.
# Input: image path
# Output: 0 on success, non-zero on failure.

    my $imgpath=shift;
	
    print "Uninstalling fake start-stop-daemon.\n" if $verbose;
    unlink "$imgpath/sbin/start-stop-daemon" or return 1;
    rename "$imgpath/sbin/start-stop-daemon.RAPT.tmp", 
	"$imgpath/sbin/start-stop-daemon" or return 1;
}	    

sub debootstrap {
# debootstrap is used to install the base system into a chroot
# Input:      target, suite, mirror
# Returns:    0 if failure, 1 if ok
    my $target = shift;
    my $suite = shift;
    my $mirror = shift;

    if (system("which debootstrap 2>/dev/null")) {
        print "ERROR: Could not find command debootstrap!\n";
        exit 1;
    }

    # create directory if not existing
    if (! -d "$target") {
        !system("mkdir -p $target")
          or croak("Could not make directory $target: $!");
    }

    my $cmd = "debootstrap --verbose $suite $target $mirror";
    print "Executing: $cmd\n" if $verbose;
    if (system($cmd)) {
        print "Failed to debootstrap, aborting.\n";
        return 0;
    }
    # Debian/Sarge sucks for one point: if we want to be able to install
    # kernel packages, the /etc/kernel-img.conf file has to be created
    # manually
    $cmd = "echo \"do_initrd = Yes\" > $target/etc/kernel-img.conf";
    print ("Executing: $cmd\n");
    if (system ($cmd)) {
        print ("Error: cannot create the file $target/etc/kernel-img.conf");
        return 0;
    }
    return 1;
}

#######
# end #
#######


# this function returns the apt list filename
sub aptlist_name {
    return $installroot."/etc/apt/sources.list";
}

# create lock file in safe way
# function only returns successfully!
sub lock_aptlist {
    my $file = &aptlist_name."_lock";

    # create lockfile with other name
    my $tfile = $file."_".$$;
    write_pid($tfile);
    push @delfiles, $tfile;

  WAIT4LOCK:
    while (-e $file) {
	my $lpid = &read_pid($file);
	if ($lpid) {
	    if (! -d "/proc/$lpid") {
		print "Stale lock found for non-existing process $lpid.".
		    " Removing it!\n" if $verbose;
		unlink($file);
		last;
	    } else {
		print "Waiting for lock $file to be released...\n" if $verbose;
		sleep(3);
	    }
	} else {
	    print "Lock $file disappeared or empty !?!\n" if $verbose;
	    last;
	}
    }
    # Now try to acquire the lock
    my $err = system("mv --reply=no $tfile $file 2>/dev/null");
    if ($err) {
	print "Couldn't acquire lock $file\n" if $verbose;
	goto WAIT4LOCK;
    }
    return;
}

sub unlock_aptlist {
    my $file = &aptlist_name . "_lock";
    my $pid = &read_pid($file);
    if ($pid != "$$") {
	print "WARNING! Unexpected pid $pid is holding the lock $file\n";
    } else {
	!system("rm -f $file") or carp("Could not remove lock $file: $!");
    }
}

sub backup_aptlist {
    my $file = &aptlist_name;
    my $backup = $file . "_bak$$";
    if (-f $file) {
	!system("mv $file $backup")
	    or carp("Could not back up $file to $backup: $!");
    }
}

sub restore_aptlist {
    my $file = &aptlist_name;
    my $backup = $file . "_bak$$";
    if (-e $backup) {
	!system("mv $backup $file")
	    or carp("Could not restore $file from $backup: $!");
    }
}

# create new sources.list file for apt resembling the current repositories
sub new_aptlist {
    my $file = &aptlist_name;
    local *OUT;
    open OUT, "> $file" or croak("Could not open $file: $!");
    for my $repo (@repos) {
	my @data = split(/\+/,$repo);
	# if there's only one word, add codename info
	if (scalar(@data) == 1) {
	    my $codename = &detect_codename();
	    push @data, ($codename, ".");
	} elsif (scalar(@data) == 2) {
	    push @data, ".";
	}
	print OUT "deb ".join(" ",@data)."\n";
    }
    close OUT;
}

sub read_pid {
    my ($file) = @_;
    local *IN;
    open IN, "$file" 
	or do {
	    return 0 if (! -e $file);
	    croak "Could not open $file";
	};
    my $pid = <IN>;
    close IN;
    return $pid;
}

sub write_pid {
    my ($file) = @_;
    local *OUT;
    open OUT, "> $file" or croak "Could not create $file";
    print OUT "$$";
    close OUT;
}


###############################################################
# stuff below this line should be deleted once packman is used!

sub find_httpdir {
    my $httpdir;
    for my $d ("httpd", "apache", "apache2") {
	if (-d "/etc/$d/conf.d") {
	    $httpdir = "/etc/$d/conf.d";
	    last;
	}
    }
    if ($verbose) {
	print "Found httpdir = $httpdir\n";
    }
    return $httpdir;
}

sub add_httpd_conf {
    my $httpdir = find_httpdir();
    my $changed = 0;
    my $err = 0;
    if ($httpdir) {
	for my $repo (@repos) {
	    if ($repo =~ /^(file:\/|\/)/) {
		$repo =~ s|^file:||;
		if (!-d $repo) {
		    print "Could not find directory $repo. Skipping.\n";
		    $err++;
		    next;
		}
		my $pname = "repo$repo";
		my $rname = $pname;
		$rname =~ s:/:_:g;
		my $cname = "$httpdir/$rname.conf";
		if (-f $cname) {
		    print "Config file $cname already existing. Skipping.\n";
		    next;
		}
		print "Exporting $repo through httpd, http://$hostname/$pname\n";
		open COUT, ">$cname" or die "Could not open $cname : $!";
		print COUT "Alias /$pname $repo\n";
		print COUT "<Directory $repo/>\n";
		print COUT "  Options Indexes\n";
		print COUT "  order allow,deny\n";
		print COUT "  allow from all\n";
		print COUT "</Directory>\n";
		close COUT;
		++$changed;
	    } else {
		print "Repository URL is not a local absolute path!\n";
		print "Skipping $repo\n";
		$err++;
		next;
	    }
	}
    } else {
	print "Could not find directory $httpdir!\n";
	print "Cannot setup httpd configuration for repositories.\n";
	$err++;
    }
    restart_httpd() if ($changed);
    return $err;
}

sub del_httpd_conf {
    my $httpdir = find_httpdir();
    my $changed = 0;
    my $err = 0;
    if ($httpdir) {
	for my $repo (@repos) {
	    if ($repo =~ /^(file:\/|\/)/) {
		$repo =~ s|^file:||;
		my $pname = "repo$repo";
		my $rname = $pname;
		$rname =~ s:/:_:g;
		my $cname = "$httpdir/$rname.conf";
		if (-f $cname) {
		    print "Deleting config file $cname\n";
		    if (unlink($cname)) {
			print "WARNING: Could not delete $cname : $!\n";
			$err++;
		    } else {
			++$changed;
		    }
		}
	    } else {
		print "Repository URL is not a local absolute path!\n";
		print "Skipping $repo\n";
		$err++;
		next;
	    }
	}
    } else {
	print "Could not find directory $httpdir!\n";
	print "Cannot delete httpd configuration for repositories.\n";
	$err++;
    }
    restart_httpd() if ($changed);
    return $err;
}

sub list_exported {
    my $httpdir = find_httpdir();
    if ($httpdir) {
	for my $repoconf (glob("$httpdir/repo_*.conf")) {
	    my $rname = basename($repoconf,".conf");
	    my ($dummy, $alias,$rdir) = split(" ",`grep "^Alias" $repoconf`);
	    chomp $rdir;
	    print "URL $alias : Repository --repo $rdir\n";
	}
    }
    exit;
}

sub restart_httpd {
    for my $httpd ("httpd", "httpd2", "apache", "apache2") {
	if (-x "/etc/init.d/$httpd") {
	    print "Restarting $httpd\n";
	    system("/etc/init.d/$httpd restart");
	    last;
	}
    }
}

sub prep_repodata {
    #
    # this routine should be replaced by the gencache call to a
    # packman instance when that will be available
    #

    if (system("which dpkg-scanpackages 2>/dev/null")) {
	print "ERROR: Could not find command dpkg-scanpackages!\n";
	exit 1;
    }
    
    # detect distribution codename
    # currently from the master server, should actually come from the pool
    my $codename = &detect_codename();
    my $subdir = "dists/$codename/binary-$archstr";
    my $err = 0;
    for my $repo (@repos) {
	next if ($repo =~ /^(http|ftp):/);
	$repo =~ s/^file://;
	$repo =~ s/\/$//;
	next if (($repo !~ m:^/:) || (! -d $repo));

	# create directory for package metadata
	if (! -d "$repo/subdir") {
	    !system("mkdir -p $repo/$subdir")
		or croak "Could not create directory $repo/$subdir";
	}

	# now generate the Package.gz file
	my $cmd = "cd $repo; dpkg-scanpackages ./ /dev/null";
	$cmd .= "| tee $subdir/Packages | gzip -c9 >$subdir/Packages.gz";
	print "Executing command: $cmd\n";
	$err += abs(system($cmd));
    }
    return $err;
}

#
# Detect codename of the targetted debian distro (sarge, breezy, ...)
# Try to do the right thing:
# - if we're installing into an image and it is already bootstrapped:
#   read the /etc/debian-release or /etc/lsb-release files in the image
# - if we're installing into a non-debootstrapped image:
#   detect codename from the first repository name (first word after the URL)
# - if we're installing locally, detect codename by reading the local files
#   /etc/debian-release or /etc/lsb-release
#
sub detect_codename {
    my (%args) =@_;
    my $codename;

    # the environment variable RAPT_DISTRO_CODENAME overrides detections
    if ($ENV{RAPT_DISTRO_CODENAME}) {
	return $ENV{RAPT_DISTRO_CODENAME};
    }

    # what are we targetting?
    if (!$installroot) {
	# local node
	$codename = &detect_codename_dir();
    } else {
	# image
	$codename = &detect_codename_dir($installroot);
	if (!$codename) {
	    $codename = &detect_codename_repo(@repos);
	}
    }
    if (!$codename) {
	croak("Could not detect distribution codename!");
    }
    if ($codename !~ /^(sarge|breezy)$/) {
	croak("Unsupported distribution codename: $codename\n");
    }
    return $codename;
}

#
# This needs improvement. For a local repo it should be able to detect the
# codename by unpacking the debian-release or lsb-release file.
# 
sub detect_codename_repo {
    my (@repos) = @_;
    # the codename of a debian-alike repo is the word after the URL
    my $repo = $repos[0];
    my ($url,$codename,$dummy) = split(/\+/,$repo);

    # for local repositories try some more tricks
    if (!$codename && ($url =~ /^file:(\S+)$/)) {
	my $path = $1;
	my @cnames = glob("$path/dists/*");
	if (scalar(@cnames) == 1) {
	    $codename = basename($cnames[0]);
	} elsif (scalar(@cnames) > 1) {
	    print "Pool seems to contain multiple codenames!\n ".
		join(", ",@cnames)."\n";
	    print "Cannot identify codename!\n";
	} else {
	    # no codename subdirectory or glob expansion failed
	    #
	    # ... code missing here ...
	    # - find .deb packages containing lsb-release and debian-release
	    # - unpack them and detect the codename
	    print "... no code for virgin repo codename detection, yet ...\n";
	}
    }
    return $codename;
}

sub detect_codename_dir {
    my ($dir) = @_;
    my $codename;

    if (-f "$dir/etc/debian_version") {
	# the codename for debian distribution is supposed to be the first
	# line of the /etc/debian_version file.
	# Moreover, we just support sarge (aka. Debian 3.1).
	open (IN, "$dir/etc/debian_version")
	    or die "Can't open file: $!\n";
        $codename = <IN>;
        close IN;
        # Since the codename may have multiple forms (3.1 vs sarge for 
        # instance, we translate to a generic codename (e.g. 3.1->sarge)
        # WARNING a \n is added after the codename when we read the file!
        switch ($codename) {
                case "3.0\n" { 
                        $codename = "sarge"; 
                }
                case "3.1\n" {
                        $codename = "sarge";
                }
        }
    } elsif (-f "$dir/etc/lsb-release") {
	# there is a chance for this being a ubuntu distro
	# it is not supported, yet, but we'll recognize it
	# in order to facilitate development for ubuntu
	open IN, "$dir/etc/lsb-release"
	    or croak "Cannot open $dir/etc/lsb-release: $!";
	while (<IN>) {
	    if (/^DISTRIB_CODENAME=(.*)$/) {
		$codename = $1;
	    }
	}
	close IN;
    }
    return $codename;
}
