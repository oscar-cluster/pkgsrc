#!/usr/bin/env python
#
# oreposd: manage OSCAR repositories, fetching packages in incoming queue,
# launching package build and updating repositories
#
# Configuration is done through oreposd.conf file
#
# Copyright (C) 2007 INRIA-IRISA
#                    Jean Parpaillon <jean.parpaillon@irisa.fr>
#

import os, sys, getopt, datetime
import string, re
import signal, subprocess
import ConfigParser

VERSION = '0.1'

USAGE = """Usage: oreposd [ -h ] [ -v ] [ -d ] [ -k ]
       -h|--help      print this and exit
       -v|--version   print version and exit
       -d|--debug     add verbosity
       -k|--kill      kill an running oreposd process
"""

debug_level = 0
incomingQueue = None
dateformat = "%b %d %H:%M:%S"

queue_list_name = [ "IncomingQueue", "BuildQueue" ]
required_configs = { "GENERAL": ["incoming_polltime",
                                 "build_polltime",
                                 "local_incoming_dir",
                                 "dist_incoming_dir",
                                 "dist_incoming_host",
                                 "dist_incoming_user"] }
children = []

#
# Classes 
#
class OreposdProcess(object):
    name = None
    
    def __init__(self, name):
        self.name = name
        signal.signal(signal.SIGTERM, lambda signum, frame: self.stop(signum))
        signal.signal(signal.SIGINT, lambda signum, frame: self.stop(signum))

    def stop(self, signum):
        for pid in children:
            os.kill(pid, signal.SIGTERM)
        info("Stopping %s process" % self.name)
        raise SystemExit(signum)

class PolledProcess(OreposdProcess):
    polltime = None

    def __init__(self, name, time):
        OreposdProcess.__init__(self, name)
        self.polltime = time
        signal.signal(signal.SIGALRM, lambda signum, frame: self.alarmHandler())
        debug("Started %s with polling time %d" % (name, time))
       
    def alarmHandler(self):
        self.run()
        signal.alarm(self.polltime)

    def start(self):
        signal.alarm(self.polltime)

    def run(self):
        raise NotImplemented

class IncomingQueue(PolledProcess):
    def __init__(self):
        PolledProcess.__init__(self, "IncomingQueue", int(Config().get("GENERAL", "incoming_polltime")))

    def run(self):
        info("Pull incoming packages")
        local_dir = "%s/" % Config().get("GENERAL", "local_incoming_dir")
        dist_dir = "%s@%s:%s/" % (Config().get("GENERAL", "dist_incoming_user"),
                                  Config().get("GENERAL", "dist_incoming_host"),
                                  Config().get("GENERAL", "dist_incoming_dir"))
        cmd = "rsync -av %s %s" % (dist_dir, local_dir)
        command(cmd)

class BuildQueue(PolledProcess):
    def __init__(self):
        PolledProcess.__init__(self, "BuildQueue", int(Config().get("GENERAL", "build_polltime")))

    def run(self):
        info("Launch incoming packages building")

class Config(object):
    __instance__ = None
    __config__ = None

    def __new__ (cls):
        if cls.__instance__ is None:
            cls.__instance__ = object.__new__(cls)
            cls.__instance__.readConfig()
        return cls.__instance__

    #
    # Read config file ./oreposd.conf
    #
    def readConfig(self):
        self.__config__ = ConfigParser.ConfigParser()

        config_files = [ os.path.join(os.path.dirname(sys.argv[0]), "oreposd.conf") ]
        fd = None
        for config_file in config_files:
            try:
                fd = open(config_file)
            except IOError, e:
                continue
            try:
                self.__config__.readfp(fd)
                debug("Read config in %s" % config_file)
            except ConfigParser.ParsingError, e:
                error("Error parsing config file:\n%s" % str(e))
                raise SystemExit(1)
            fd.close()

        if fd == None:
            error("No config file")
            raise SystemExit(1)

        # Just to test mandatory options (raise NoOptionError if not found)
        for section in required_configs.keys():
            for opt in required_configs[section]:
                self.__config__.get(section, opt)

    def get(self, section, opt):
        return self.__config__.get(section, opt)
    
#
# Helper functions
#
def debug(msg):
    if debug_level > 0:
        print "%s [DEBUG] %s" % (datetime.datetime.now().strftime(dateformat), msg)

def info(msg):
    print "%s [INFO] %s" % (datetime.datetime.now().strftime(dateformat), msg)

def warn(msg):
    print "%s [WARN] %s" % (datetime.datetime.now().strftime(dateformat), msg)

def error(msg):
    print >> sys.stderr, "%s [ERROR] %s" % (datetime.datetime.now().strftime(dateformat), msg)

def command(command, cwd=os.getcwd()):
    debug("Execute: %s" % command)
    exe = subprocess.Popen(command,
                           cwd=cwd,
                           bufsize=0,
                           stdin=None,
                           stdout=subprocess.PIPE,
                           stderr=subprocess.PIPE,
                           shell=True)
    if debug_level > 0:
        for l in exe.stdout:
            info(l.strip())
    for l in exe.stderr:
        error(l.strip())
    return exe.wait()

def alreadyRunning():
    """ Return pid of an already running process of oreposd, if any.
    """
    try:
        fd = open(Config().get("GENERAL", "pidfile"), 'r')
        pid = int(fd.readline().strip())
        return pid
    except IOError, e:
        return None

def savePid():
    fd = open(Config().get("GENERAL", "pidfile"), 'w')
    fd.write("%d" % os.getpid())
    fd.close()

def rmPid():
    os.unlink(Config().get("GENERAL", "pidfile"))

#
# Main
#
def main():
    global debug_level
    global queue_list_name
    global children

    # Parse command line options
    try:
        (opts, args) = getopt.getopt(sys.argv[1:],
                                     'vhdk',
                                     ['version', 'help', 'debug', 'kill'])
    except getopt.error, msg:
        error(msg)
        SystemExit(1)

    killMode = False
    for option, arg in opts:
        if option in ('-h', '--help'):
            print USAGE
            return
        elif option in ('-v', '--version'):
            print VERSION
            return
        elif option in ('-d', '--debug'):
            debug_level += 1
        elif option in ('-k', '--kill'):
            killMode = True

    try:
        Config()
    except ConfigParser.NoOptionError, e:
        error(e)
        raise SystemExit(1)

    pid = alreadyRunning()
    if pid and killMode:
        info("Terminate oreposd (pid %d)" % pid)
        os.kill(pid, signal.SIGTERM)
        rmPid()
        raise SystemExit(0)
    elif not pid and killMode:
        error("No oreposd process already running")
        raise SystemExit(1)
    elif pid and not killMode:
        error("An oreposd process is already running (%s exists)" % Config().get("GENERAL", "pidfile"))
        raise SystemExit(1)
    savePid()

    main = OreposdProcess("main")
    for queue_name in queue_list_name:
        pid = os.fork()
        if pid == 0:
            os.setsid()
            queue = eval("%s()" % queue_name)
            queue.start()
            break
        else:
            children.append(pid)

    while True:
        signal.pause()

# Main
if __name__ == '__main__':
    try:
        main()
    except KeyboardInterrupt:
        print "exiting due to user interrupt."

# vim: set expandtab shiftwidth=4 :
